<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D åŠ¨æ€æ•°æ®å¯è§†åŒ–ç³»ç»Ÿ - å•æ–‡ä»¶ç‰ˆ</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #000000;
        }
        /* éšè—æ»šåŠ¨æ¡ */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(59, 130, 246, 0.5); border-radius: 10px; }
        
        /* Loading é®ç½©åŠ¨ç”» */
        #loading-screen {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: flex; justify-content: center; align-items: center;
            color: #6366f1; font-weight: bold; letter-spacing: 0.2em;
            transition: opacity 0.5s ease;
        }
        input[type="range"] { accent-color: #6366f1; }
    </style>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@19.0.0",
        "react-dom": "https://esm.sh/react-dom@19.0.0",
        "react-dom/client": "https://esm.sh/react-dom@19.0.0/client",
        "react/jsx-runtime": "https://esm.sh/react@19.0.0/jsx-runtime",
        "three": "https://esm.sh/three@0.182.0",
        "three/examples/jsm/loaders/EXRLoader": "https://esm.sh/three@0.182.0/examples/jsm/loaders/EXRLoader",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@9.0.0?external=react,react-dom,three",
        "@react-three/drei": "https://esm.sh/@react-three/drei@10.0.0?external=react,react-dom,three,@react-three/fiber",
        "lucide-react": "https://esm.sh/lucide-react@0.475.0?external=react"
      }
    }
    </script>
</head>
<body>
    <div id="loading-screen">INITIALIZING SYSTEM...</div>
    
    <div id="root"></div>

    <script type="text/babel" data-type="module" data-presets="react">
        /** @jsx React.createElement */
        /** @jsxFrag React.Fragment */

        import React, { useRef, useMemo, useState, useEffect, Suspense } from 'react';
        import ReactDOM from 'react-dom/client';
        import { Canvas, useThree, useFrame } from '@react-three/fiber';
        import { 
          OrbitControls, 
          PerspectiveCamera, 
          Environment, 
          PerformanceMonitor,
          AdaptiveDpr,
          AdaptiveEvents,
          Text,
          Billboard,
          ContactShadows,
          Float,
          BakeShadows,
          Stars,
          Grid,
          Sparkles
        } from '@react-three/drei';
        import * as THREE from 'three';
        import { 
          Play, Pause, RotateCcw, Monitor, Camera, MousePointer2, Settings2, X, BarChart3, MoveUp
        } from 'lucide-react';

        // ç§»é™¤ Loading é®ç½©
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => loadingScreen.remove(), 500);
            }, 1000); // ç¨å¾®å»¶è¿Ÿä»¥ä¿è¯æ¸²æŸ“å‡†å¤‡å°±ç»ª
        }

        // ==========================================
        // å…¨å±€é…ç½®ä¸æ•°æ®
        // ==========================================
        const CONFIG = {
          "ui": {
            "title": "2024 äºšæ´² GDP æ’åé¢„æµ‹",
            "subTitle": "æ•°æ®æ¥æºï¼šå›½é™…è´§å¸æ”¿åºœç»„ç»‡ (IMF) ç»Ÿè®¡æŠ¥å‘Š",
            "meta": "ç”µå½±çº§æ˜Ÿç³»å¯è§†åŒ–ç³»ç»Ÿ"
          },
          "data": [
            { "id": "1", "name": "ä¸­å›½", "value": 18744, "color": "#ff3e3e", "flag": "ğŸ‡¨ğŸ‡³" },
            { "id": "2", "name": "æ—¥æœ¬", "value": 4026, "color": "#ff5e5e", "flag": "ğŸ‡¯ğŸ‡µ" },
            { "id": "3", "name": "å°åº¦", "value": 3913, "color": "#ff9f43", "flag": "ğŸ‡®ğŸ‡³" },
            { "id": "4", "name": "éŸ©å›½", "value": 1713, "color": "#feca57", "flag": "ğŸ‡°ğŸ‡·" },
            { "id": "5", "name": "å°åº¦å°¼è¥¿äºš", "value": 1396, "color": "#ffdd59", "flag": "ğŸ‡®ğŸ‡©" },
            { "id": "6", "name": "æ²™ç‰¹é˜¿æ‹‰ä¼¯", "value": 1238, "color": "#48c48f", "flag": "ğŸ‡¸ğŸ‡¦" },
            { "id": "7", "name": "æ–°åŠ å¡", "value": 547, "color": "#1dd1a1", "flag": "ğŸ‡¸ğŸ‡¬" },
            { "id": "8", "name": "ä»¥è‰²åˆ—", "value": 540, "color": "#00d2d3", "flag": "ğŸ‡®ğŸ‡±" },
            { "id": "9", "name": "é˜¿è”é…‹", "value": 537, "color": "#54a0ff", "flag": "ğŸ‡¦ğŸ‡ª" },
            { "id": "10", "name": "æ³°å›½", "value": 526, "color": "#5f27cd", "flag": "ğŸ‡¹ğŸ‡­" }
          ].sort((a, b) => a.value - b.value) 
        };

        const SCALE_FACTOR = 0.0006;
        const BAR_SPACING = 7.5;
        const SCENE_FLOOR_Y = 18; 

        // æ›¿æ¢ Enum ä¸ºæ™®é€šå¯¹è±¡
        const CameraView = {
          FREE: 'FREE',
          CINEMATIC: 'CINEMATIC',
          FRONT: 'FRONT'
        };

        // --- å¢å¼ºç‰ˆï¼šè¶…æ„Ÿæ˜Ÿç³»èƒŒæ™¯ ---
        const DeepSpaceGalaxy = () => {
          const groupRef = useRef(null);

          // æç¼“æ…¢çš„èƒŒæ™¯æ—‹è½¬
          useFrame((state) => {
            if (groupRef.current) {
              groupRef.current.rotation.y = state.clock.elapsedTime * 0.01;
              groupRef.current.rotation.x = Math.sin(state.clock.elapsedTime * 0.05) * 0.1;
            }
          });

          return (
            <group ref={groupRef}>
              {/* 1. åŸºç¡€é™æ€æ˜Ÿåœº */}
              <Stars radius={400} depth={50} count={6000} factor={1.5} saturation={0} fade speed={0.05} />
              
              {/* 2. æ˜Ÿç³»æ˜Ÿäº‘äº‘é›¾ (Nebula) */}
              <Sparkles count={35} scale={600} size={45} speed={0.1} opacity={0.3} color="#1e3a8a" />
              <Sparkles count={25} scale={450} size={35} speed={0.15} opacity={0.2} color="#7e22ce" />
              <Sparkles count={20} scale={350} size={25} speed={0.2} opacity={0.25} color="#0ea5e9" />
              
              {/* 3. æ˜Ÿç³»æ ¸å¿ƒ (Galaxy Core) */}
              <Float speed={2} rotationIntensity={0.2} floatIntensity={0.5}>
                <group position={[150, 80, -500]}>
                   <mesh scale={[180, 180, 180]}>
                     <sphereGeometry args={[1, 32, 32]} />
                     <meshBasicMaterial color="#4338ca" transparent opacity={0.15} blending={THREE.AdditiveBlending} />
                   </mesh>
                   <mesh scale={[40, 40, 40]}>
                     <sphereGeometry args={[1, 16, 16]} />
                     <meshBasicMaterial color="#e0e7ff" transparent opacity={0.8} blending={THREE.AdditiveBlending} />
                   </mesh>
                   <pointLight intensity={80} distance={2000} color="#818cf8" />
                </group>
              </Float>

              {/* 4. å¾®å¼±çš„æ˜Ÿç³»å°˜åŸƒå¸¦ */}
              <Sparkles count={50} scale={[800, 50, 800]} size={3} speed={0.3} opacity={0.4} color="#ffffff" />

              {/* 5. è¿œå¤æ˜Ÿåº§è¿çº¿ */}
              <Constellations />
            </group>
          );
        };

        // --- å¹½çµæ˜Ÿåº§è¿çº¿ ---
        const Constellations = () => {
          const lineGeom = useMemo(() => {
            const points = [];
            const radius = 650;
            const count = 15; 
            
            for (let i = 0; i < count; i++) {
              const phi = Math.random() * Math.PI;
              const theta = Math.random() * Math.PI * 2;
              const center = new THREE.Vector3().setFromSphericalCoords(radius, phi, theta);
              
              let prev = center.clone();
              const segments = 2 + Math.floor(Math.random() * 3);
              
              for (let j = 0; j < segments; j++) {
                const next = prev.clone().add(new THREE.Vector3(
                  (Math.random() - 0.5) * 150,
                  (Math.random() - 0.5) * 150,
                  (Math.random() - 0.5) * 150
                )).normalize().multiplyScalar(radius);
                
                points.push(prev.clone(), next.clone());
                prev = next;
              }
            }
            return new THREE.BufferGeometry().setFromPoints(points);
          }, []);

          return (
            <lineSegments geometry={lineGeom}>
              <lineBasicMaterial color="#6366f1" transparent opacity={0.03} blending={THREE.AdditiveBlending} depthWrite={false} />
            </lineSegments>
          );
        };

        // --- å•ä¸ªæŸ±çŠ¶å›¾ç»„ä»¶ ---
        const Bar = ({ item, index, total, progress, active, thickness, labelOffset }) => {
          const meshRef = useRef(null);
          const growth = Math.max(0, Math.min(1, progress - index));
          
          const labelOpacity = THREE.MathUtils.smoothstep(growth, 0, 0.2);
          const labelScale = THREE.MathUtils.lerp(0.6, 1, THREE.MathUtils.smoothstep(growth, 0, 0.3));
          
          const targetHeight = item.value * SCALE_FACTOR;
          const currentHeight = Math.max(0.1, targetHeight * growth);
          
          const labelBaseY = Math.max(labelOffset, currentHeight + labelOffset);
          
          const totalWidth = (total - 1) * BAR_SPACING;
          const xPos = (index * BAR_SPACING) - (totalWidth / 2);

          useFrame((state) => {
            if (meshRef.current) {
              const material = meshRef.current.material;
              const pulse = active ? Math.sin(state.clock.elapsedTime * 6) * 0.15 + 0.25 : 0.05;
              material.emissiveIntensity = THREE.MathUtils.lerp(material.emissiveIntensity, pulse, 0.1);
            }
          });

          return (
            <group position={[xPos, 0, 0]}>
              <mesh 
                ref={meshRef}
                scale={[thickness, currentHeight, thickness]} 
                position={[0, currentHeight / 2, 0]}
                castShadow
                receiveShadow
              >
                <boxGeometry args={[3.5, 1, 3.5]} />
                <meshStandardMaterial 
                  color={item.color} 
                  emissive={item.color}
                  emissiveIntensity={0.05}
                  roughness={0.1}
                  metalness={0.8}
                />
              </mesh>

              {progress > index && (
                <Billboard position={[0, labelBaseY, 0]}>
                  <Float speed={1.2} rotationIntensity={0.1} floatIntensity={0.15}>
                    <group scale={labelScale}>
                      <Text position={[0, 2.5, 0]} fontSize={1.6} fillOpacity={labelOpacity} anchorX="center">{item.flag}</Text>
                      <Text position={[0, 1.2, 0]} fontSize={0.6} fontWeight="bold" color="#ffffff" fillOpacity={labelOpacity} anchorX="center">{item.name}</Text>
                      <Text position={[0, 0, 0]} fontSize={1.4} fontWeight="black" color={active ? "#ffffff" : item.color} fillOpacity={labelOpacity} anchorX="center">
                        {Math.round(item.value * growth).toLocaleString()}
                      </Text>
                    </group>
                  </Float>
                </Billboard>
              )}
            </group>
          );
        };

        // --- æ‘„åƒæœºæ§åˆ¶å™¨ ---
        const CameraController = ({ view, progress, data, isPlaying, camAngle, camDistance, autoRotate }) => {
          const { camera, size } = useThree();
          const controlsRef = useRef(null);
          const targetPos = useMemo(() => new THREE.Vector3(), []);
          const lookAtTarget = useMemo(() => new THREE.Vector3(), []);
          
          const total = data.length;
          const totalWidth = (total - 1) * BAR_SPACING;
          const maxHeight = data[total - 1].value * SCALE_FACTOR;

          useFrame((state) => {
            if (!controlsRef.current) return;
            const controls = controlsRef.current;
            
            const currentActiveIdx = Math.max(0, Math.min(total - 1, progress - 0.5));
            const floorIdx = Math.floor(currentActiveIdx);
            const ceilIdx = Math.min(total - 1, floorIdx + 1);
            const alpha = currentActiveIdx - floorIdx;
            
            const heightAtFocus = (data[floorIdx].value + (data[ceilIdx].value - data[floorIdx].value) * alpha) * SCALE_FACTOR;
            const xPosAtFocus = (currentActiveIdx * BAR_SPACING) - (totalWidth / 2);

            if (view === CameraView.CINEMATIC) {
              const heightRatio = Math.min(1.0, heightAtFocus / 10);
              const focusCenterY = SCENE_FLOOR_Y + (heightAtFocus * (0.35 - heightRatio * 0.1)) + 3;
              const rad = ((camAngle + 30) * Math.PI) / 180;
              
              lookAtTarget.set(xPosAtFocus, focusCenterY, 0);
              controls.target.lerp(lookAtTarget, 0.08);

              if (isPlaying || progress < total) {
                targetPos.set(
                  xPosAtFocus + Math.sin(rad) * camDistance, 
                  focusCenterY + 4, 
                  Math.cos(rad) * camDistance
                );
                camera.position.lerp(targetPos, 0.04);
              }
              controls.update();
            } 
            else if (view === CameraView.FRONT) {
              const fovRad = camera.fov * (Math.PI / 180);
              const aspect = size.width / size.height;
              const contentHeight = maxHeight + 10;
              const contentWidth = totalWidth + 10;
              
              const availableHeightRatio = 0.5;
              const distByWidth = (contentWidth / 2) / Math.tan(fovRad / 2) / aspect;
              const distByHeight = (contentHeight / 2) / Math.tan(fovRad / 2) / availableHeightRatio;
              
              const finalDist = Math.max(distByWidth, distByHeight, camDistance * 1.5);
              const targetY = SCENE_FLOOR_Y + (maxHeight / 2) - 1;

              const rotationSpeed = autoRotate ? state.clock.elapsedTime * 0.1 : 0;
              const rotAngle = (camAngle * Math.PI / 180) + rotationSpeed;

              lookAtTarget.set(0, targetY, 0);
              targetPos.set(
                Math.sin(rotAngle) * finalDist,
                targetY + (finalDist * 0.2),
                Math.cos(rotAngle) * finalDist
              );
              
              controls.target.lerp(lookAtTarget, 0.06);
              camera.position.lerp(targetPos, 0.06);
              controls.update();
            }
          });

          return (
            <OrbitControls 
              ref={controlsRef} 
              makeDefault 
              enableDamping 
              dampingFactor={0.05} 
              minDistance={5} 
              maxDistance={2500} 
              maxPolarAngle={Math.PI / 2.02} 
            />
          );
        };

        const SceneContent = (props) => {
          const activeIndex = Math.floor(props.progress);

          return (
            <React.Fragment>
              {/* çº¯å‡€çš„å®‡å®™é»‘èƒŒæ™¯ */}
              <color attach="background" args={['#000000']} />
              <Suspense fallback={null}>
                <Environment preset="night" />
              </Suspense>

              {/* è¶…æ„Ÿæ˜Ÿç³»èƒŒæ™¯å±‚ */}
              <DeepSpaceGalaxy />

              <fog attach="fog" args={['#000000', 300, 1200]} />
              
              {props.showGrid && (
                <group position={[0, SCENE_FLOOR_Y, 0]}>
                  <Grid 
                    infiniteGrid 
                    fadeDistance={200} 
                    fadeStrength={4} 
                    cellSize={5} 
                    sectionSize={25} 
                    sectionThickness={1.5} 
                    sectionColor="#1e293b" 
                    cellColor="#020617" 
                  />
                </group>
              )}

              <PerspectiveCamera makeDefault position={[0, 60, 200]} fov={30} />
              <CameraController {...props} />
              
              <directionalLight position={[100, 100, 100]} intensity={1.5} />
              <spotLight position={[-50, 150, 50]} intensity={3} angle={0.3} penumbra={1} castShadow />
              <ambientLight intensity={0.4} />

              <group position={[0, SCENE_FLOOR_Y, 0]}>
                <ContactShadows opacity={0.7} scale={400} blur={2.5} far={40} resolution={1024} color="#000" position={[0, -0.01, 0]} />
                {props.data.map((item, idx) => (
                  <Bar 
                    key={item.id} 
                    item={item} 
                    index={idx} 
                    total={props.data.length} 
                    progress={props.progress} 
                    active={activeIndex === idx} 
                    thickness={props.thickness} 
                    labelOffset={props.labelOffset}
                  />
                ))}
              </group>
              <BakeShadows />
            </React.Fragment>
          );
        };

        // --- æ‚¬æµ®æ§åˆ¶ç•Œé¢ ---
        const ControlsUI = (props) => {
          const [showSettings, setShowSettings] = useState(false);
          const progressPercent = Math.min(100, Math.round((props.progress / props.maxProgress) * 100));
          const currentRank = props.totalItems - Math.min(props.totalItems - 1, props.currentIndex);

          return (
            <div className="absolute bottom-6 left-1/2 -translate-x-1/2 w-[95%] max-w-4xl flex flex-col items-center bg-zinc-950/80 backdrop-blur-3xl border border-white/5 shadow-[0_35px_60px_-15px_rgba(0,0,0,1)] rounded-[2.5rem] overflow-visible transition-all">
              <div className="w-[calc(100%-4rem)] h-1 bg-white/5 relative group cursor-pointer overflow-hidden mt-5 rounded-full">
                <div 
                  className="absolute left-0 top-0 h-full bg-indigo-500 z-10 shadow-[0_0_15px_rgba(99,102,241,0.8)]" 
                  style={{ width: `${(props.progress / props.maxProgress) * 100}%` }} 
                />
                <input 
                  type="range" min="0" max={props.maxProgress} step="0.0001" value={props.progress} 
                  onChange={(e) => { props.setProgress(parseFloat(e.target.value)); props.setIsPlaying(false); }} 
                  className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20" 
                />
              </div>

              <div className="w-full px-8 py-4 flex items-center justify-between gap-3">
                <div className="flex items-center gap-3">
                  <button 
                    onClick={() => { if (props.progress >= props.maxProgress - 0.05) props.onReset(); else props.setIsPlaying(!props.isPlaying); }} 
                    className={`w-10 h-10 rounded-full flex items-center justify-center transition-all transform hover:scale-110 active:scale-95 ${props.isPlaying ? 'bg-white text-black' : 'bg-indigo-600 text-white shadow-xl shadow-indigo-500/20'}`}
                  >
                    {props.isPlaying ? <Pause size={20} fill="currentColor" /> : <Play size={20} fill="currentColor" className="ml-0.5" />}
                  </button>
                  <button 
                    onClick={props.onReset} 
                    className="w-8 h-8 flex items-center justify-center text-zinc-500 hover:text-white hover:bg-white/10 rounded-full transition-colors"
                  >
                    <RotateCcw size={16} />
                  </button>
                </div>

                <div className="flex items-center flex-grow justify-center gap-4">
                  <div className="hidden sm:flex items-center px-4 border-r border-white/10 group min-w-[180px]">
                    <div className="flex flex-col">
                      <div className="flex items-center gap-2">
                        <span className="text-[9px] font-black text-indigo-400 bg-indigo-400/10 px-1.5 py-0.5 rounded uppercase tracking-tighter">
                          Rank {currentRank}
                        </span>
                        <span className="text-sm font-black text-white italic truncate max-w-[110px]">
                          {props.currentItem?.name || 'End Sequence'}
                        </span>
                        {props.currentItem && <span className="text-lg leading-none">{props.currentItem.flag}</span>}
                      </div>
                    </div>
                  </div>

                  <div className="flex bg-black/50 p-1.5 rounded-2xl border border-white/5">
                    {[ 
                      { id: CameraView.CINEMATIC, icon: <Camera size={13} />, label: 'å½±é™¢' }, 
                      { id: CameraView.FRONT, icon: <Monitor size={13} />, label: 'å…¨æ™¯' }, 
                      { id: CameraView.FREE, icon: <MousePointer2 size={13} />, label: 'è‡ªç”±' }
                    ].map((v) => (
                      <button 
                        key={v.id} 
                        onClick={() => props.setView(v.id)} 
                        className={`flex items-center gap-2 px-4 py-2 rounded-xl text-[10px] font-black tracking-wide transition-all ${props.view === v.id ? 'bg-indigo-100 text-indigo-950 shadow-lg' : 'text-zinc-500 hover:text-zinc-200'}`}
                      >
                        {v.icon}<span>{v.label}</span>
                      </button>
                    ))}
                  </div>
                </div>

                <div className="flex items-center gap-4 relative">
                  <div className="hidden md:flex flex-col items-end">
                    <span className="text-[11px] font-black text-indigo-500 tabular-nums tracking-widest">{progressPercent}%</span>
                  </div>
                  <button onClick={() => setShowSettings(!showSettings)} className={`w-9 h-9 rounded-full border border-white/10 flex items-center justify-center transition-all ${showSettings ? 'bg-indigo-600 text-white shadow-lg shadow-indigo-500/30' : 'text-zinc-500 hover:text-white hover:bg-white/5'}`}>
                    {showSettings ? <X size={18} /> : <Settings2 size={18} />}
                  </button>

                  {showSettings && (
                    <div className="absolute bottom-[calc(100%+2rem)] right-0 w-80 bg-zinc-950/95 backdrop-blur-3xl border border-white/10 p-6 rounded-[2rem] shadow-[0_0_100px_rgba(0,0,0,1)] z-50 flex flex-col gap-5 animate-in fade-in zoom-in-95 slide-in-from-bottom-6 duration-300">
                      <div className="flex items-center gap-2 border-b border-white/5 pb-3">
                        <BarChart3 size={16} className="text-indigo-500" />
                        <h3 className="text-[11px] font-black text-zinc-100 uppercase tracking-[0.2em]">ç³»ç»Ÿè°ƒä¼˜</h3>
                      </div>
                      
                      <div className="space-y-3">
                        <div className="flex justify-between text-[9px] font-black uppercase text-zinc-500">
                          <span>æ’­æ”¾å€é€Ÿ</span>
                          <span className="text-indigo-400">{props.speed.toFixed(1)}x</span>
                        </div>
                        <input type="range" min="0.1" max="4.0" step="0.1" value={props.speed} onChange={(e) => props.setSpeed(parseFloat(e.target.value))} className="w-full accent-indigo-500 h-1 bg-zinc-900 rounded-full appearance-none cursor-pointer" />
                      </div>

                      <div className="space-y-3">
                        <div className="flex justify-between text-[9px] font-black uppercase text-zinc-500">
                          <span className="flex items-center gap-1"><MoveUp size={11} /> æ ‡ç­¾é«˜åº¦</span>
                          <span className="text-indigo-400">{props.labelOffset.toFixed(1)}m</span>
                        </div>
                        <input type="range" min="0.5" max="8.0" step="0.1" value={props.labelOffset} onChange={(e) => props.setLabelOffset(parseFloat(e.target.value))} className="w-full accent-indigo-500 h-1 bg-zinc-900 rounded-full appearance-none cursor-pointer" />
                      </div>

                      <div className="space-y-3">
                        <div className="flex justify-between text-[9px] font-black uppercase text-zinc-500">
                          <span>ç¯ç»•è§’åº¦</span>
                          <span className="text-indigo-400">{props.angle}Â°</span>
                        </div>
                        <input type="range" min="0" max="360" step="1" value={props.angle} onChange={(e) => props.setAngle(parseInt(e.target.value))} className="w-full accent-indigo-500 h-1 bg-zinc-900 rounded-full appearance-none cursor-pointer" />
                      </div>

                      <div className="space-y-3">
                        <div className="flex justify-between text-[9px] font-black uppercase text-zinc-500">
                          <span>è§‚å¯Ÿè·ç¦»</span>
                          <span className="text-indigo-400">{props.distance}m</span>
                        </div>
                        <input type="range" min="10" max="150" step="1" value={props.distance} onChange={(e) => props.setDistance(parseInt(e.target.value))} className="w-full accent-indigo-500 h-1 bg-zinc-900 rounded-full appearance-none cursor-pointer" />
                      </div>

                      <div className="grid grid-cols-2 gap-3 pt-3">
                        <button 
                          onClick={() => props.setShowGrid(!props.showGrid)}
                          className={`py-3 rounded-xl text-[9px] font-black uppercase transition-all ${props.showGrid ? 'bg-indigo-600/20 text-indigo-400 border border-indigo-500/30 shadow-inner' : 'bg-white/5 text-zinc-500'}`}
                        >
                          å®‡å®™ç½‘æ ¼
                        </button>
                        <button 
                          onClick={() => props.setAutoRotate(!props.autoRotate)}
                          className={`py-3 rounded-xl text-[9px] font-black uppercase transition-all ${props.autoRotate ? 'bg-indigo-600/20 text-indigo-400 border border-indigo-500/30 shadow-inner' : 'bg-white/5 text-zinc-500'}`}
                        >
                          è‡ªåŠ¨èˆªè¡Œ
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        };

        const App = () => {
          const [progress, setProgress] = useState(0);
          const [isPlaying, setIsPlaying] = useState(true);
          const [view, setView] = useState(CameraView.CINEMATIC);
          
          // Settings State
          const [playbackSpeed, setPlaybackSpeed] = useState(1.2); 
          const [camAngle, setCamAngle] = useState(0); 
          const [camDistance, setCamDistance] = useState(48); 
          const [thickness, setThickness] = useState(1.0);
          const [labelOffset, setLabelOffset] = useState(1.8); 
          const [showGrid, setShowGrid] = useState(true);
          const [autoRotate, setAutoRotate] = useState(true); 

          const totalItems = CONFIG.data.length;
          const maxProgress = totalItems;
          
          const currentIndex = Math.floor(progress);
          const currentItem = CONFIG.data[Math.min(totalItems - 1, currentIndex)];

          const handleReset = () => { 
            setProgress(0); 
            setIsPlaying(true); 
            setView(CameraView.CINEMATIC); 
            setAutoRotate(true);
          };

          useEffect(() => {
            if (!isPlaying) return;
            let frameId;
            const animate = () => {
              setProgress((prev) => {
                const next = prev + (0.005 * playbackSpeed);
                if (next >= maxProgress) { 
                  setIsPlaying(false); 
                  setTimeout(() => {
                     setView(v => v === CameraView.CINEMATIC ? CameraView.FRONT : v);
                     setAutoRotate(true);
                  }, 300);
                  return maxProgress; 
                }
                return next;
              });
              frameId = requestAnimationFrame(animate);
            };
            frameId = requestAnimationFrame(animate);
            return () => cancelAnimationFrame(frameId);
          }, [isPlaying, maxProgress, playbackSpeed]);

          return (
            <div className="flex flex-col w-full h-[100dvh] bg-black text-white font-sans select-none overflow-hidden relative">
              <div className="absolute inset-0 z-0">
                <Canvas 
                  shadows 
                  gl={{ antialias: true, toneMapping: THREE.ACESFilmicToneMapping }}
                  camera={{ fov: 30, near: 0.1, far: 3000 }}
                >
                  <PerformanceMonitor />
                  <AdaptiveDpr />
                  <AdaptiveEvents />
                  <SceneContent 
                    data={CONFIG.data} 
                    progress={progress} 
                    view={view} 
                    isPlaying={isPlaying} 
                    camAngle={camAngle} 
                    camDistance={camDistance}
                    thickness={thickness}
                    labelOffset={labelOffset}
                    showGrid={showGrid}
                    autoRotate={autoRotate}
                  />
                </Canvas>
              </div>

              <div className="relative top-0 left-0 p-10 md:p-14 z-10 pointer-events-none w-full flex flex-col gap-2">
                <div className="flex items-center gap-3">
                  <div className="w-2.5 h-2.5 rounded-full bg-indigo-500 shadow-[0_0_15px_rgba(99,102,241,1)] animate-pulse" />
                  <span className="text-[11px] font-black tracking-[0.8em] uppercase text-indigo-400/80">{CONFIG.ui.meta}</span>
                </div>
                <h1 className="text-5xl md:text-7xl font-black tracking-tighter leading-none text-white drop-shadow-[0_15px_15px_rgba(0,0,0,0.9)]">
                  {CONFIG.ui.title}
                </h1>
                <p className="text-zinc-500 text-xs md:text-sm font-bold tracking-[0.3em] opacity-60 uppercase">
                  {CONFIG.ui.subTitle}
                </p>
              </div>

              <div className="z-30 pointer-events-auto">
                <ControlsUI 
                  isPlaying={isPlaying} setIsPlaying={setIsPlaying} 
                  progress={progress} setProgress={setProgress} 
                  maxProgress={maxProgress} view={view} setView={setView} 
                  speed={playbackSpeed} setSpeed={setPlaybackSpeed} 
                  angle={camAngle} setAngle={setCamAngle} 
                  distance={camDistance} setDistance={setCamDistance} 
                  thickness={thickness} setThickness={setThickness}
                  labelOffset={labelOffset} setLabelOffset={setLabelOffset}
                  showGrid={showGrid} setShowGrid={setShowGrid}
                  autoRotate={autoRotate} setAutoRotate={setAutoRotate}
                  onReset={handleReset}
                  currentItem={currentItem}
                  currentIndex={currentIndex}
                  totalItems={totalItems}
                />
              </div>

              <div className="absolute top-1/2 left-10 -translate-y-1/2 flex flex-col gap-10 opacity-10 pointer-events-none hidden lg:flex">
                <div className="flex flex-col gap-2">
                  <div className="w-16 h-0.5 bg-indigo-500" />
                  <span className="text-[9px] font-bold tracking-widest uppercase">Asia Nations</span>
                </div>
                <div className="flex flex-col gap-2">
                  <div className="w-16 h-0.5 bg-zinc-100" />
                  <span className="text-[9px] font-bold tracking-widest uppercase">GDP Value ($B)</span>
                </div>
              </div>
            </div>
          );
        };

        const rootElement = document.getElementById('root');
        if (rootElement) {
          ReactDOM.createRoot(rootElement).render(<App />);
        }
    </script>
</body>
</html>
