<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Êô∫ËÉΩÊäòÁ∫øÂõæ - ÁªàÊûÅÊòüÁ≥ªÂÆåÂÖ®‰Ωì (ÁÑ¶ÁÇπ‰øÆÂ§çÁâà)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000000; font-family: 'Inter', sans-serif; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        #loading-screen {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #6366f1; font-weight: bold; letter-spacing: 0.2em;
            transition: opacity 0.5s ease; pointer-events: none;
        }
        input[type="range"] { accent-color: #6366f1; }
    </style>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "three": "https://esm.sh/three@0.150.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.10.0?deps=three@0.150.0",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.57.0?deps=three@0.150.0,react@18.2.0,react-dom@18.2.0",
        "lucide-react": "https://esm.sh/lucide-react@0.344.0?external=react"
      }
    }
    </script>
</head>
<body>
    <div id="loading-screen">
        <div>SYSTEM INITIALIZING...</div>
    </div>
    
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useRef, useMemo, useState, useEffect, Suspense } from 'react';
        import ReactDOM from 'react-dom/client';
        import { Canvas, useThree, useFrame } from '@react-three/fiber';
        import { 
          OrbitControls, PerspectiveCamera, Environment, PerformanceMonitor,
          AdaptiveDpr, AdaptiveEvents, Text, Billboard, ContactShadows,
          Float, BakeShadows, Stars, Sparkles, Line
        } from '@react-three/drei';
        import * as THREE from 'three';
        import { 
          Play, Pause, RotateCcw, Monitor, Camera, MousePointer2, Settings2, X, Activity, MoveUp, TrendingUp, BarChart3
        } from 'lucide-react';

        setTimeout(() => {
            const ls = document.getElementById('loading-screen');
            if(ls) { ls.style.opacity = '0'; setTimeout(() => ls.remove(), 500); }
        }, 1500);

        // --- ÂÖ®Â±ÄÈÖçÁΩÆ ---
        const CONFIG = {"ui":{"highlightTitle":"3D ÊòüÁ≥ªÂõæË°®","title":"2005-2024Âπ¥‰∏≠ÂõΩGDPËµ∞ÂäøÂõæ","subTitle":"Êï∞ÊçÆÊù•Ê∫êÔºöÂõΩÂÆ∂ÁªüËÆ°Â±Ä","unit":"‰∫øÂÖÉ","axisX":"Âπ¥‰ªΩ","axisY":"GDPÔºà‰∫øÂÖÉÔºâ"},"data":[{"id":"2005","name":"2005","value":184937,"color":"#4dabf7","icon":"üìä"},{"id":"2006","name":"2006","value":216314,"color":"#4dabf7","icon":"üìä"},{"id":"2007","name":"2007","value":265810,"color":"#4dabf7","icon":"üìä"},{"id":"2008","name":"2008","value":314045,"color":"#4dabf7","icon":"üìä"},{"id":"2009","name":"2009","value":340902,"color":"#4dabf7","icon":"üìä"},{"id":"2010","name":"2010","value":397983,"color":"#4dabf7","icon":"üìä"},{"id":"2011","name":"2011","value":473104,"color":"#4dabf7","icon":"üìä"},{"id":"2012","name":"2012","value":519322,"color":"#4dabf7","icon":"üìä"},{"id":"2013","name":"2013","value":568845,"color":"#4dabf7","icon":"üìä"},{"id":"2014","name":"2014","value":636463,"color":"#4dabf7","icon":"üìä"},{"id":"2015","name":"2015","value":689052,"color":"#4dabf7","icon":"üìä"},{"id":"2016","name":"2016","value":744127,"color":"#4dabf7","icon":"üìä"},{"id":"2017","name":"2017","value":827122,"color":"#4dabf7","icon":"üìä"},{"id":"2018","name":"2018","value":900309,"color":"#4dabf7","icon":"üìä"},{"id":"2019","name":"2019","value":990865,"color":"#4dabf7","icon":"üìä"},{"id":"2020","name":"2020","value":1015986,"color":"#4dabf7","icon":"üìä"},{"id":"2021","name":"2021","value":1143670,"color":"#4dabf7","icon":"üìä"},{"id":"2022","name":"2022","value":1210207,"color":"#4dabf7","icon":"üìä"},{"id":"2023","name":"2023","value":1260582,"color":"#4dabf7","icon":"üìä"},{"id":"2024","name":"2024","value":1349084,"color":"#4dabf7","icon":"üìä"}]};

        const BAR_SPACING = 8.0;
        const SCENE_FLOOR_Y = 18; 
        const VISUAL_MIN = 5;
        const VISUAL_MAX = 60;
        const CameraView = { FREE: 'FREE', CINEMATIC: 'CINEMATIC', FRONT: 'FRONT' };

        // --- Âú∫ÊôØÁªÑ‰ª∂ ---
        const DeepSpaceGalaxy = () => {
          const groupRef = useRef(null);
          useFrame((state) => {
            if (groupRef.current) {
              groupRef.current.rotation.y = state.clock.elapsedTime * 0.01;
            }
          });
          return (
            <group ref={groupRef}>
              <Stars radius={400} depth={50} count={6000} factor={1.5} saturation={0} fade speed={0.05} />
              <Sparkles count={35} scale={600} size={45} speed={0.1} opacity={0.3} color="#1e3a8a" />
              <Float speed={2} rotationIntensity={0.2} floatIntensity={0.5}>
                <group position={[150, 80, -500]}>
                   <mesh scale={[180, 180, 180]}><sphereGeometry args={[1, 32, 32]} /><meshBasicMaterial color="#4338ca" transparent opacity={0.15} blending={THREE.AdditiveBlending} /></mesh>
                   <pointLight intensity={80} distance={2000} color="#818cf8" />
                </group>
              </Float>
              <Sparkles count={50} scale={[800, 50, 800]} size={3} speed={0.3} opacity={0.4} color="#ffffff" />
            </group>
          );
        };

        const SmartGrid = ({ minVal, maxVal, getHeight, steepness, show }) => {
          if (!show) return null;
          const steps = 5;
          const lines = [];
          const range = maxVal - minVal;
          for (let i = 0; i <= steps; i++) {
             const val = minVal + (range * (i / steps));
             lines.push(val);
          }
          return (
            <group>
              {lines.map((val, i) => {
                const yPos = getHeight(val) * steepness;
                return (
                  <group key={i} position={[0, yPos, 0]}>
                    <Line points={[[-60, 0, 0], [60, 0, 0]]} color="#6366f1" opacity={0.15} transparent dashed dashScale={2} dashSize={1} gapSize={1} />
                    <Billboard position={[-65, 0, 0]}>
                      <Text fontSize={1.2} color="#818cf8" fillOpacity={0.5} anchorX="right" anchorY="middle">{val.toLocaleString(undefined, { maximumFractionDigits: 0 })}</Text>
                    </Billboard>
                    <mesh position={[-60, 0, 0]}><sphereGeometry args={[0.1, 8, 8]} /><meshBasicMaterial color="#6366f1" opacity={0.5} transparent /></mesh>
                  </group>
                )
              })}
            </group>
          )
        };

        const LineNode = ({ item, prevItem, index, total, progress, active, thickness, labelOffset, steepness, getHeight }) => {
          const growth = Math.max(0, Math.min(1, progress - index));
          const targetY = getHeight(item.value) * steepness;
          const xPos = (index * BAR_SPACING) - ((total - 1) * BAR_SPACING / 2);
          const prevX = index > 0 ? ((index - 1) * BAR_SPACING) - ((total - 1) * BAR_SPACING / 2) : xPos;
          const prevY = prevItem ? getHeight(prevItem.value) * steepness : 0; 

          const segment = useMemo(() => {
            if (!prevItem || index === 0 || growth <= 0) return null;
            const start = new THREE.Vector3(prevX, prevY, 0);
            const end = new THREE.Vector3(xPos, targetY, 0);
            const currentEnd = start.clone().lerpVectors(start, end, growth); 
            const direction = new THREE.Vector3().subVectors(currentEnd, start);
            const length = direction.length();
            if (length < 0.001) return null;
            const midpoint = new THREE.Vector3().addVectors(start, currentEnd).multiplyScalar(0.5);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.clone().normalize());
            return { midpoint, quaternion, length };
          }, [prevItem, index, prevX, prevY, xPos, targetY, growth]);

          const labelOpacity = THREE.MathUtils.smoothstep(growth, 0, 0.2);
          const sphereRef = useRef();
          useFrame((state) => {
            if (sphereRef.current) sphereRef.current.scale.setScalar(active ? 1 + Math.sin(state.clock.elapsedTime * 8) * 0.1 : 1);
          });

          return (
            <group>
              {segment && (
                <mesh position={segment.midpoint} quaternion={segment.quaternion}>
                  <cylinderGeometry args={[thickness * 0.15, thickness * 0.15, segment.length, 8]} />
                  <meshStandardMaterial color={item.color} emissive={item.color} emissiveIntensity={active ? 2 : 0.5} transparent opacity={0.8} />
                </mesh>
              )}
              {growth > 0.01 && (
                <group position={[xPos, targetY, 0]}>
                  <mesh ref={sphereRef} scale={[thickness, thickness, thickness]}>
                    <sphereGeometry args={[0.4, 32, 32]} />
                    <meshStandardMaterial color={item.color} emissive={item.color} emissiveIntensity={active ? 3 : 0.8} />
                  </mesh>
                  {active && <mesh><sphereGeometry args={[0.6 * thickness, 16, 16]} /><meshBasicMaterial color={item.color} transparent opacity={0.2} /></mesh>}
                  <Billboard position={[0, labelOffset, 0]}>
                    <Float speed={1.2} rotationIntensity={0.1} floatIntensity={0.15}>
                        <Text position={[0, 2.5, 0]} fontSize={1.6} fillOpacity={labelOpacity} anchorX="center">{item.flag}</Text>
                        <Text position={[0, 1.2, 0]} fontSize={0.6} fontWeight="bold" color="#ffffff" fillOpacity={labelOpacity} anchorX="center">{item.name}</Text>
                        <Text position={[0, 0, 0]} fontSize={1.4} fontWeight="black" color={active ? "#ffffff" : item.color} fillOpacity={labelOpacity} anchorX="center">
                          {(() => { const val = item.value * (growth > 0.9 ? 1 : growth); return Number.isInteger(val) ? Math.round(val).toLocaleString() : val.toFixed(0); })()}
                        </Text>
                    </Float>
                  </Billboard>
                  <mesh position={[0, -targetY / 2, 0]}><cylinderGeometry args={[0.05, 0.05, targetY, 4]} /><meshBasicMaterial color={item.color} transparent opacity={0.1} /></mesh>
                </group>
              )}
            </group>
          );
        };

        // --- Ê†∏ÂøÉ‰øÆÂ§çÔºöÊëÑÂÉèÊú∫ÊéßÂà∂Âô® ---
        const CameraController = ({ view, progress, data, isPlaying, camAngle, camDistance, autoRotate, steepness, getHeight }) => {
          const { camera, size } = useThree();
          const controlsRef = useRef(null);
          const vec = useMemo(() => new THREE.Vector3(), []);
          const total = data.length;
          const totalWidth = (total - 1) * BAR_SPACING;
          const visualMaxHeight = VISUAL_MAX * steepness;

          useFrame((state) => {
            if (!controlsRef.current) return;
            const controls = controlsRef.current;
            
            const currentActiveIdx = Math.max(0, Math.min(total - 1, progress - 0.5));
            const floorIdx = Math.floor(currentActiveIdx);
            const ceilIdx = Math.min(total - 1, floorIdx + 1);
            const alpha = currentActiveIdx - floorIdx;
            
            const realValAtFocus = data[floorIdx].value + (data[ceilIdx].value - data[floorIdx].value) * alpha;
            const heightAtFocus = getHeight(realValAtFocus) * steepness;
            const xPosAtFocus = (currentActiveIdx * BAR_SPACING) - (totalWidth / 2);

            if (view === CameraView.CINEMATIC) {
              // „ÄêÂÖ≥ÈîÆ‰øÆÂ§ç„ÄëÁõ¥Êé•ÁõØ‰ΩèÊäòÁ∫øÈ´òÂ∫¶ÔºåËÄå‰∏çÊòØÈ´òÂ∫¶ÁöÑ‰∏ÄÂçä„ÄÇËøôÊ†∑Ê†áÁ≠æÊ∞∏ËøúÂú®‰∏≠ÂøÉ„ÄÇ
              const focusCenterY = SCENE_FLOOR_Y + heightAtFocus; 
              
              const rad = ((camAngle + 30) * Math.PI) / 180;
              const dynamicZoomOut = Math.max(0, (heightAtFocus - 20) * 0.9); 
              const activeDistance = camDistance + dynamicZoomOut;
              
              // ÁõÆÊ†áÁÇπÔºöÈîÅÂÆöÊäòÁ∫ø‰∏äÁöÑÁÇπ
              controls.target.lerp(vec.set(xPosAtFocus, focusCenterY, 0), 0.1);
              
              if (isPlaying || progress < total) {
                // ÊëÑÂÉèÊú∫‰ΩçÁΩÆÔºöÂú®ÁÑ¶ÁÇπ‰πã‰∏äÔºå‰øùÊåÅ‰øØËßÜ
                camera.position.lerp(vec.clone().set(
                    xPosAtFocus + Math.sin(rad) * activeDistance, 
                    focusCenterY + 8 + (heightAtFocus * 0.1), // Âä®ÊÄÅÂçáÁ©∫Ôºå‰øùËØÅÂ§¥È°∂ÊúâÁ©∫Èó¥
                    Math.cos(rad) * activeDistance
                ), 0.05);
              }
              controls.update();
            } 
            else if (view === CameraView.FRONT) {
              const fovRad = camera.fov * (Math.PI / 180);
              const aspect = size.width / size.height;
              const distByWidth = (totalWidth * 1.1 + 15) / 2 / Math.tan(fovRad / 2) / aspect;
              const distByHeight = (visualMaxHeight * 1.2 + 10) / 2 / Math.tan(fovRad / 2);
              const finalDist = Math.max(distByWidth, distByHeight, camDistance * 1.2);
              const targetY = SCENE_FLOOR_Y + (visualMaxHeight * 0.45);
              const rotAngle = (camAngle * Math.PI / 180) + (autoRotate ? state.clock.elapsedTime * 0.1 : 0);

              controls.target.lerp(vec.set(0, targetY, 0), 0.06);
              camera.position.lerp(vec.clone().set(Math.sin(rotAngle) * finalDist, targetY + (visualMaxHeight * 0.15) + 5, Math.cos(rotAngle) * finalDist), 0.06);
              controls.update();
            }
          });
          return <OrbitControls ref={controlsRef} makeDefault enableDamping dampingFactor={0.05} minDistance={5} maxDistance={2500} maxPolarAngle={Math.PI / 2.02} />;
        };

        const SceneContent = (props) => {
          const activeIndex = Math.floor(props.progress);
          const getHeight = (val) => {
             const range = props.maxVal - props.minVal;
             if (range === 0) return (VISUAL_MAX + VISUAL_MIN) / 2;
             const normalized = (val - props.minVal) / range;
             return VISUAL_MIN + (normalized * (VISUAL_MAX - VISUAL_MIN));
          };

          return (
            <React.Fragment>
              <color attach="background" args={['#000000']} />
              <Suspense fallback={null}><Environment preset="night" /></Suspense>
              <DeepSpaceGalaxy />
              <fog attach="fog" args={['#000000', 100, 2000]} />
              <group position={[0, SCENE_FLOOR_Y, 0]}>
                <SmartGrid minVal={props.minVal} maxVal={props.maxVal} getHeight={getHeight} steepness={props.steepness} show={props.showAxisLines} />
                <ContactShadows opacity={0.7} scale={400} blur={2.5} far={40} resolution={1024} color="#000" position={[0, -0.01, 0]} />
                {props.data.map((item, idx) => (
                  <LineNode key={item.id} item={item} prevItem={idx > 0 ? props.data[idx - 1] : null}
                    index={idx} total={props.data.length} progress={props.progress} 
                    active={activeIndex === idx} thickness={props.thickness}
                    labelOffset={props.labelOffset} steepness={props.steepness} 
                    getHeight={getHeight} 
                  />
                ))}
              </group>
              <PerspectiveCamera makeDefault position={[0, 60, 200]} fov={30} />
              <CameraController {...props} getHeight={getHeight} />
              <directionalLight position={[100, 100, 100]} intensity={1.5} />
              <spotLight position={[-50, 150, 50]} intensity={3} angle={0.3} penumbra={1} castShadow />
              <ambientLight intensity={0.4} />
              <BakeShadows />
            </React.Fragment>
          );
        };

        // --- Controls UI (ÂÆåÊï¥Ë±™ÂçéÁâà) ---
        const ControlsUI = (props) => {
          const [showSettings, setShowSettings] = useState(false);
          const progressPercent = Math.min(100, Math.round((props.progress / props.maxProgress) * 100));
          const currentRank = props.totalItems - Math.min(props.totalItems - 1, props.currentIndex);

          return (
            <div className="absolute bottom-6 left-1/2 -translate-x-1/2 w-[95%] max-w-4xl flex flex-col items-center bg-zinc-950/80 backdrop-blur-3xl border border-white/5 shadow-2xl rounded-[2.5rem] transition-all">
              
              <div className="w-[calc(100%-4rem)] h-1 bg-white/5 relative group cursor-pointer overflow-hidden mt-5 rounded-full">
                <div className="absolute left-0 top-0 h-full bg-indigo-500 z-10 shadow-[0_0_15px_rgba(99,102,241,0.8)]" style={{ width: `${(props.progress / props.maxProgress) * 100}%` }} />
                <input type="range" min="0" max={props.maxProgress} step="0.0001" value={props.progress} onChange={(e) => { props.setProgress(parseFloat(e.target.value)); props.setIsPlaying(false); }} className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20" />
              </div>

              <div className="w-full px-8 py-4 flex items-center justify-between gap-3">
                <div className="flex items-center gap-3">
                  <button onClick={() => { if (props.progress >= props.maxProgress - 0.05) props.onReset(); else props.setIsPlaying(!props.isPlaying); }} className={`w-10 h-10 rounded-full flex items-center justify-center transition-all transform hover:scale-110 active:scale-95 ${props.isPlaying ? 'bg-white text-black' : 'bg-indigo-600 text-white shadow-xl shadow-indigo-500/20'}`}>
                    {props.isPlaying ? <Pause size={20} fill="currentColor" /> : <Play size={20} fill="currentColor" className="ml-0.5" />}
                  </button>
                  <button onClick={props.onReset} className="w-8 h-8 flex items-center justify-center text-zinc-500 hover:text-white hover:bg-white/10 rounded-full transition-colors"><RotateCcw size={16} /></button>
                </div>

                <div className="flex items-center flex-grow justify-center gap-4">
                  {/* Rank Èù¢Êùø */}
                  <div className="hidden sm:flex items-center px-4 border-r border-white/10 group min-w-[180px]">
                    <div className="flex flex-col">
                      <div className="flex items-center gap-2">
                        <span className="text-[9px] font-black text-indigo-400 bg-indigo-400/10 px-1.5 py-0.5 rounded uppercase tracking-tighter">Rank {currentRank}</span>
                        <span className="text-sm font-black text-white italic truncate max-w-[110px]">{props.currentItem?.name || 'End Sequence'}</span>
                        {props.currentItem && <span className="text-lg leading-none">{props.currentItem.flag}</span>}
                      </div>
                    </div>
                  </div>

                  <div className="flex bg-black/50 p-1.5 rounded-2xl border border-white/5">
                    {[ { id: CameraView.CINEMATIC, icon: <Camera size={13} />, label: 'ÂΩ±Èô¢' }, { id: CameraView.FRONT, icon: <Monitor size={13} />, label: 'ÂÖ®ÊôØ' }, { id: CameraView.FREE, icon: <MousePointer2 size={13} />, label: 'Ëá™Áî±' }].map((v) => (
                      <button key={v.id} onClick={() => props.setView(v.id)} className={`flex items-center gap-2 px-4 py-2 rounded-xl text-[10px] font-black tracking-wide transition-all ${props.view === v.id ? 'bg-indigo-100 text-indigo-950 shadow-lg' : 'text-zinc-500 hover:text-zinc-200'}`}>
                        {v.icon}<span>{v.label}</span>
                      </button>
                    ))}
                  </div>
                </div>

                <div className="flex items-center gap-4 relative">
                  <div className="hidden md:flex flex-col items-end"><span className="text-[11px] font-black text-indigo-500 tabular-nums tracking-widest">{progressPercent}%</span></div>
                  <button onClick={() => setShowSettings(!showSettings)} className={`w-9 h-9 rounded-full border border-white/10 flex items-center justify-center transition-all ${showSettings ? 'bg-indigo-600 text-white shadow-lg shadow-indigo-500/30' : 'text-zinc-500 hover:text-white hover:bg-white/5'}`}>
                    {showSettings ? <X size={18} /> : <Settings2 size={18} />}
                  </button>

                  {showSettings && (
                    <div className="absolute bottom-[calc(100%+2rem)] right-0 w-80 bg-zinc-950/95 backdrop-blur-3xl border border-white/10 p-6 rounded-[2rem] shadow-2xl z-50 flex flex-col gap-5 animate-in fade-in zoom-in-95 slide-in-from-bottom-6 duration-300">
                      <div className="flex items-center gap-2 border-b border-white/5 pb-3"><BarChart3 size={16} className="text-indigo-500" /><h3 className="text-[11px] font-black text-zinc-100 uppercase tracking-[0.2em]">Á≥ªÁªüË∞É‰ºò</h3></div>
                      <div className="space-y-3">
                        <div className="flex justify-between text-[9px] font-black uppercase text-zinc-500"><span className="flex items-center gap-1"><TrendingUp size={11} /> ÂûÇÁõ¥Êãâ‰º∏ (Steepness)</span><span className="text-indigo-400">{props.steepness.toFixed(1)}x</span></div>
                        <input type="range" min="0.5" max="3.0" step="0.1" value={props.steepness} onChange={(e) => props.setSteepness(parseFloat(e.target.value))} className="w-full accent-indigo-500 h-1 bg-zinc-900 rounded-full appearance-none cursor-pointer" />
                      </div>
                      <div className="space-y-3">
                        <div className="flex justify-between text-[9px] font-black uppercase text-zinc-500"><span>Êí≠ÊîæÂÄçÈÄü</span><span className="text-indigo-400">{props.speed.toFixed(1)}x</span></div>
                        <input type="range" min="0.1" max="4.0" step="0.1" value={props.speed} onChange={(e) => props.setSpeed(parseFloat(e.target.value))} className="w-full accent-indigo-500 h-1 bg-zinc-900 rounded-full appearance-none cursor-pointer" />
                      </div>
                      <div className="space-y-3">
                        <div className="flex justify-between text-[9px] font-black uppercase text-zinc-500"><span className="flex items-center gap-1"><MoveUp size={11} /> Ê†áÁ≠æÈ´òÂ∫¶</span><span className="text-indigo-400">{props.labelOffset.toFixed(1)}m</span></div>
                        <input type="range" min="0.5" max="8.0" step="0.1" value={props.labelOffset} onChange={(e) => props.setLabelOffset(parseFloat(e.target.value))} className="w-full accent-indigo-500 h-1 bg-zinc-900 rounded-full appearance-none cursor-pointer" />
                      </div>
                      <div className="grid grid-cols-2 gap-3 pt-3">
                        <button onClick={() => props.setShowAxisLines(!props.showAxisLines)} className={`py-3 rounded-xl text-[9px] font-black uppercase transition-all ${props.showAxisLines ? 'bg-indigo-600/20 text-indigo-400 border border-indigo-500/30' : 'bg-white/5 text-zinc-500'}`}>ÂèÇËÄÉÊ†áÁ∫ø</button>
                        <button onClick={() => props.setAutoRotate(!props.autoRotate)} className={`py-3 rounded-xl text-[9px] font-black uppercase transition-all ${props.autoRotate ? 'bg-indigo-600/20 text-indigo-400 border border-indigo-500/30' : 'bg-white/5 text-zinc-500'}`}>Ëá™Âä®Ëà™Ë°å</button>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        };

        const App = () => {
          const sortedData = useMemo(() => [...CONFIG.data].sort((a, b) => a.value - b.value), []);
          const { minVal, maxVal } = useMemo(() => {
              const vals = sortedData.map(d => d.value);
              return { minVal: Math.min(...vals), maxVal: Math.max(...vals) };
          }, [sortedData]);

          const [progress, setProgress] = useState(0);
          const [isPlaying, setIsPlaying] = useState(true);
          const [view, setView] = useState(CameraView.CINEMATIC);
          const [playbackSpeed, setPlaybackSpeed] = useState(1.0); 
          const [camAngle, setCamAngle] = useState(0); 
          const [camDistance, setCamDistance] = useState(48); 
          const [thickness, setThickness] = useState(1.0);
          const [labelOffset, setLabelOffset] = useState(2.2); 
          const [autoRotate, setAutoRotate] = useState(true); 
          const [steepness, setSteepness] = useState(1.0);
          const [showAxisLines, setShowAxisLines] = useState(true);

          const totalItems = sortedData.length;
          const maxProgress = totalItems;
          const currentIndex = Math.floor(progress);
          const currentItem = sortedData[Math.min(totalItems - 1, currentIndex)];

          const handleReset = () => { 
            setProgress(0); setIsPlaying(true); setView(CameraView.CINEMATIC); setAutoRotate(true);
          };

          useEffect(() => {
            if (!isPlaying) return;
            let frameId;
            const animate = () => {
              setProgress((prev) => {
                const next = prev + (0.005 * playbackSpeed);
                if (next >= maxProgress) { 
                  setIsPlaying(false); 
                  setTimeout(() => { setView(v => v === CameraView.CINEMATIC ? CameraView.FRONT : v); setAutoRotate(true); }, 300);
                  return maxProgress; 
                }
                return next;
              });
              frameId = requestAnimationFrame(animate);
            };
            frameId = requestAnimationFrame(animate);
            return () => cancelAnimationFrame(frameId);
          }, [isPlaying, maxProgress, playbackSpeed]);

          return (
            <div className="flex flex-col w-full h-[100dvh] bg-black text-white font-sans select-none overflow-hidden relative">
              <div className="absolute inset-0 z-0">
                <Canvas shadows gl={{ antialias: true, toneMapping: THREE.ACESFilmicToneMapping }} camera={{ fov: 30, near: 0.1, far: 3000 }}>
                  <PerformanceMonitor />
                  <AdaptiveDpr />
                  <AdaptiveEvents />
                  <SceneContent 
                    data={sortedData} progress={progress} view={view} isPlaying={isPlaying} 
                    speed={playbackSpeed} camAngle={camAngle} camDistance={camDistance}
                    thickness={thickness} labelOffset={labelOffset} autoRotate={autoRotate}
                    steepness={steepness} showAxisLines={showAxisLines}
                    minVal={minVal} maxVal={maxVal}
                  />
                </Canvas>
              </div>

              <div className="relative top-0 left-0 p-10 md:p-14 z-10 pointer-events-none w-full flex flex-col gap-2">
                <div className="flex items-center gap-3">
                  <div className="w-2.5 h-2.5 rounded-full bg-indigo-500 shadow-[0_0_15px_rgba(99,102,241,1)] animate-pulse" />
                  <span className="text-[11px] font-black tracking-[0.8em] uppercase text-indigo-400/80">{CONFIG.ui.meta}</span>
                </div>
                <h1 className="text-5xl md:text-7xl font-black tracking-tighter leading-none text-white drop-shadow-[0_15px_15px_rgba(0,0,0,0.9)]">
                  {CONFIG.ui.title}
                  {CONFIG.ui.unit && <span className="text-2xl md:text-3xl ml-4 opacity-70">({CONFIG.ui.unit})</span>}
                </h1>
                <p className="text-zinc-500 text-xs md:text-sm font-bold tracking-[0.3em] opacity-60 uppercase">{CONFIG.ui.subTitle}</p>
              </div>

              <div className="z-30 pointer-events-auto">
                <ControlsUI 
                  isPlaying={isPlaying} setIsPlaying={setIsPlaying} progress={progress} setProgress={setProgress} 
                  maxProgress={maxProgress} view={view} setView={setView} speed={playbackSpeed} setSpeed={setPlaybackSpeed} 
                  angle={camAngle} setAngle={setCamAngle} distance={camDistance} setDistance={setCamDistance} 
                  thickness={thickness} setThickness={setThickness} labelOffset={labelOffset} setLabelOffset={setLabelOffset}
                  autoRotate={autoRotate} setAutoRotate={setAutoRotate} steepness={steepness} setSteepness={setSteepness}
                  showAxisLines={showAxisLines} setShowAxisLines={setShowAxisLines} onReset={handleReset}
                  currentItem={currentItem} currentIndex={currentIndex} totalItems={totalItems}
                />
              </div>

              <div className="absolute top-1/2 left-10 -translate-y-1/2 flex flex-col gap-10 opacity-10 pointer-events-none hidden lg:flex">
                <div className="flex flex-col gap-2"><div className="w-16 h-0.5 bg-indigo-500" /><span className="text-[9px] font-bold tracking-widest uppercase">{CONFIG.ui.axisX}</span></div>
                <div className="flex flex-col gap-2"><div className="w-16 h-0.5 bg-zinc-100" /><span className="text-[9px] font-bold tracking-widest uppercase">{CONFIG.ui.axisY}</span></div>
              </div>
            </div>
          );
        };

        const rootElement = document.getElementById('root');
        if (rootElement) { ReactDOM.createRoot(rootElement).render(<App />); }
    </script>
</body>
</html>
